routeTable = {}
daemonTable = {}
socketTable = {}
networkDaemonWakeup = nil
local modemSide

function netInit (_side)
	--initialize network communications
	if daemonTable["netd"] then
		local open = false
		if not _side then
			for n,side in pairs(rs.getSides()) do
				if peripheral.getType(side) == "modem" then
					modemSide = side
					rednet.open(side)
					open = true
					break
				end
			end
		else
			modemSide = _side
			rednet.open(_side)
			open = true
		end
		--keep in mind that netd must be an exception since packets coming to it do not always have route numbers yet.
		if open then coroutine.resume(daemonTable["netd"], packet.new("SI", 0, "announce")) end
	end
	return false
end

function daemonAdd (dName, dFunction, socket)
	if socket then socketTable[tonumber(socket)] = dName end
	daemonTable[dName] = coroutine.create(dFunction)
	coroutine.resume(daemonTable[dName], 0, "SI", "start")
end

function daemonRemove (dName)
	if daemonTable[dName] then
		for sNum, sInfo in pairs(socketTable) do
			if sInfo == dName then
				sNum = nil
			end
		end
		daemonTable[dName] = nil
		return true
	else
		return false
	end
end

function routeFromName (name)
	for rNum,rInfo in ipairs(routeTable) do
		if rInfo and rInfo.name == tostring(name) then return rNum end
	end
	return false
end

function routeFromCID (compID)
	for rNum,rInfo in ipairs(routeTable) do
		if rInfo and rInfo.idNum == tonumber(compID) then return rNum end
	end
	return false
end

function nameFromRoute (route)
	if routeTable[route] then
		return routeTable[route].name
	else
		return false
	end
end

function CIDFromRoute (route)
	if routeTable[route] then
		return routeTable[route].idNum
	else
		return false
	end
end

function send(pack, ll)
	local routeNum = net.routeFromCID(pack.destination)
	if routeNum then
		local route = net.routeTable[routeNum]
		if route.cost > 0 then
			return peripheral.call(modemSide, "transmit", route.gateway, os.computerID(), pack:encapsulate(ll))
		else
			if net.routeTable[net.routeFromCID(pack.destination)].type == "T" then
				coroutine.resume(daemonTable.netd, 0, "turtlepacket>"..pack.destination.." "..pack:tostring())
			else
				return peripheral.call(modemSide, "transmit", route.idNum, os.computerID(), pack:tostring())
			end
		end
	elseif pack.type == "RM" then
		return peripheral.call(modemSide, "transmit", pack.destination, os.computerID(), pack.payload)
	end
	return false
end

function raw_send (id, message)
	return peripheral.call(modemSide, "transmit", id, os.computerID(), message)
end

function add_route (idNumber, compType, compName, gateway, cost)
	idNumber = tonumber(idNumber)
	compType = tostring(compType)
	compName = tostring(compName)
	if gateway then
		gateway = tonumber(gateway)
	else
		gateway = 0
	end
	if cost then
		cost = tonumber(cost)
	else
		cost = 0
	end
	for rNum,rInfo in ipairs(routeTable) do
		if rInfo then
			if idNumber == rInfo.idNum then
				if rInfo.type ~= compType then
					rInfo.type = compType
				end
				if rInfo.cost > cost then
					rInfo.gateway = gateway
					rInfo.cost = cost
				end
				return rNum
			end
		end
	end
	local route = {}
	route.idNum = idNumber
	route.type = compType
	route.name = compName
	route.gateway = gateway
	route.cost = cost
	table.insert(routeTable, route)
	return #routeTable
end

function remove_route (route)
	if route then
		local file = io.open("/etc/hosts", "w" )
		if file then
			for rNum, rInfo in ipairs(routeTable) do
				if rNum ~= route then
					file:write(rInfo.idNum..":"..rInfo.gateway..","..rInfo.cost..";"..rInfo.type.." "..rInfo.name.."\n")
				end
			end
			file:close()
		end
		routeTable[route] = false
	end
end

function message(id, msg, dist)
	local packetType, inSocket, foreignSocket, body
	--pass the local computer ID as the destination, forwarded packets will automatically reassign the actual destination.
	local pack = packet.reconstruct(msg, os.computerID(), id, dist)
	if not pack.type then
		--does not match.
		return true
	end
	local header = string.sub(msg, 1, 2)
	if header == "PF" or header == "PC" then
		if pack.destination == os.computerID() then
			if header == "PC" then rednet.send(id, "PS:4,4;".. msg) else rednet.send(id, "HK:4,4;"..msg) end
			os.queueEvent("modem_message", modemSide, pack.destination, pack.origin, pack:tostring(), false)
			return false
		else
			return "packet_inbound", pack
		end
	elseif pack.type == "HA" or pack.type == "HT" or pack.type == "HI" then
		if daemonTable.netd then
			coroutine.resume(daemonTable.netd, pack)
			return false
		end
	elseif pack.type == "RM" then
		return "rednet_message", pack.payload, 0
	else
		return "packet_inbound", pack
	end
end

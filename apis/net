routeTable = {}
daemonTable = {}
socketTable = {}

function netInit (_side)
	--initialize network communications
	local packet = "HA:4,4;"
	local label = os.getComputerLabel()
	if label then
		if turtle then
			packet = packet.."T "..label
		else
			if daemonTable.routed then
				packet = packet.."R "..label
			else
				packet = packet.."C "..label
			end
		end
		local open = false
		if not _side then
			for n,side in pairs(rs.getSides()) do
				if peripheral.getType(side) == "modem" then
					rednet.open(side)
					open = true
					break
				end
			end
		else
			rednet.open(_side)
			open = true
		end
		if open then return rednet.broadcast(packet) end
	end
	return false
end

function daemonAdd (dName, dFunction, socket)
	if socket then socketTable[tonumber(socket)] = dName end
	daemonTable[dName] = coroutine.create(dFunction)
	coroutine.resume(daemonTable[dName], 0, "SI", "start")
end

function daemonRemove (dName)
	if daemonTable[dName] then
		for sNum, sInfo in pairs(socketTable) do
			if sInfo == dName then
				sNum = nil
			end
		end
		daemonTable[dName] = nil
		return true
	else
		return false
	end
end

function routeFromName (name)
	for rNum,rInfo in ipairs(routeTable) do
		if rInfo.name == tostring(name) then return rNum end
	end
	return false
end

function routeFromCID (compID)
	for rNum,rInfo in ipairs(routeTable) do
		if rInfo.idNum == tonumber(compID) then return rNum end
	end
	return false
end

function nameFromRoute (route)
	if routeTable[route] then
		return routeTable[route].name
	else
		return false
	end
end

function CIDFromRoute (route)
	if routeTable[route] then
		return routeTable[route].idNum
	else
		return false
	end
end

function packet_send (pType, routeNum, message)
	routeNum = tonumber(routeNum)
	if routeTable[routeNum] then
		if routeTable[routeNum].gateway ~= 0 then
			return rednet.send(routeTable[routeNum].gateway, "PF:"..routeTable[routeNum].idNum..","..os.computerID().."<"..pType..":"..tostring(message)..">")
		end
		return rednet.send(routeTable[routeNum].idNum, pType..":"..tostring(message))
	else return false end
end

function packet_receive (idNumber, message)
	idNumber = tonumber(idNumber)
	for rNum,rInfo in ipairs(routeTable) do
		if idNumber == rInfo.idNum then
			return rNum, string.sub(message, 1, 2), string.match(message, ":(.*)")
		end
	end
end

function add_route (idNumber, compType, compName, gateway, cost)
	idNumber = tonumber(idNumber)
	compType = tostring(compType)
	compName = tostring(compName)
	if gateway then
		gateway = tonumber(gateway)
	else
		gateway = 0
	end
	if cost then
		cost = tonumber(cost)
	else
		cost = 0
	end
	for rNum,rInfo in ipairs(routeTable) do
		if idNumber == rInfo.idNum then
			if rInfo.type ~= compType then
				rInfo.type = compType
			end
			if rInfo.cost > cost then
				rInfo.gateway = gateway
				rInfo.cost = cost
			end
			return rNum
		end
	end
	local route = {}
	route.idNum = idNumber
	route.type = compType
	route.name = compName
	route.gateway = gateway
	route.cost = cost
	table.insert(routeTable, route)
	return #routeTable
end

function remove_route (route)
	if route then
		local file = io.open("/etc/hosts", "w" )
		if file then
			for rNum, rInfo in ipairs(routeTable) do
				if rNum ~= route then
					file:write(rInfo.idNum..":"..rInfo.gateway..","..rInfo.cost..";"..rInfo.type.." "..rInfo.name.."\n")
				end
			end
			file:close()
		end
		routeTable[route] = false
	end
end

function message(id, msg, dist)
	local packetType, inSocket, foreignSocket, body
	if msg then
		--packetType must be grabbed separately, as forwared packets do not follow the same structure.
		packetType = string.sub(msg, 1, 2)
		inSocket, foreignSocket, body = string.match(msg, "^%a%a:(%d+),(%d+);(.*)")
	end
	--If packetType is nil, this isn't a LyqydNet packet.  Hope that returning it gets it to the right place.
	if packetType == "PF" or packetType == "PC" then
		if tonumber(string.match(msg, ":(%d+),%d+<")) == os.computerID() then
			if packetType == "PC" then packet_send("PS", routeFromCID(id), msg) end
			return msg(string.match(msg, ":%d+,(%d+)<"), string.match(msg, "<(.*)>"), false)
		else
			os.queueEvent("socket_message", 4, id, msg, false)
			return false
		end
	else
		--if the string.match failed, assume this is not a LyqydNet packet.
		if not inSocket then return id, msg, dist end
		os.queueEvent("socket_message", inSocket, id, msg, dist)
		return false
	end
end

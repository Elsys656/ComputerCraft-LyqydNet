connectionTable = {}
local pTypeLookup = {
	pTypeLookup.query = "SQ",
	pTypeLookup.response = "SR",
	pTypeLookup.data = "SP",
	pTypeLookup.done = "SB",
	pTypeLookup.close = "SC",
	pTypeLookup.fileQuery = "FQ",
	pTypeLookup.fileSend = "FS",
	pTypeLookup.fileResponse = "FR",
	pTypeLookup.fileHeader = "FH",
	pTypeLookup.fileData = "FD",
	pTypeLookup.fileEnd = "FE",
	pTypeLookup.fileCopy = "FC",
	pTypeLookup.fileDelete = "FM",
	pTypeLookup.fileMove = "FV",
	pTypeLookup.fileMakeDirectory = "FK",
	pTypeLookup.fileList = "FL",
	pTypeLookup.fileInformation = "FI",
	pTypeLookup.instruction = "SI",
	pTypeLookup.SQ = "query",
	pTypeLookup.SR = "response",
	pTypeLookup.SP = "data",
	pTypeLookup.SB = "done",
	pTypeLookup.SC = "close",
	pTypeLookup.FQ = "fileQuery",
	pTypeLookup.FS = "fileSend",
	pTypeLookup.FR = "fileResponse",
	pTypeLookup.FH = "fileHeader",
	pTypeLookup.FD = "fileData",
	pTypeLookup.FE = "fileEnd",
	pTypeLookup.FC = "fileCopy",
	pTypeLookup.FM = "fileDelete",
	pTypeLookup.FV = "fileMove",
	pTypeLookup.FK = "fileMakeDirectory",
	pTypeLookup.FL = "fileList",
	pTypeLookup.FI = "fileInformation",
	pTypeLookup.SI = "instruction"
}

function listen (port, time)
	--used by foreground servers to wait for incoming packets.
	local listenTimeOut = nil
	if time then listenTimeOut = os.startTimer(time) end
	while true do
		local event, p1, p2, p3 = os.pullEvent()
		if event == "timer" and p1 == listenTimeOut then
			return false
		elseif event == "rednet_message" then
			routeNum, packetType, message, dist = net.rednet_message(p1, p2, p3)
			if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
			if routeNum then
				if port == string.match(message, "^(%d+),%d+;") then
					for cNum, cInfo in pairs(connectionTable) do
						if cInfo.route == routeNum and cInfo.localport = port then return cNum, packetType, string.match(message, ";(.*)"), dist end
					end
					local conn = {}
					conn.route = routeNum
					conn.name = net.nameFromRoute(routeNum)
					conn.localport = port
					conn.foreignport = string.match(message, "^%d+,(%d+);")
					table.insert(connectionTable, conn)
					return #connectionTable, packetType, string.match(message, ";(.*)"), dist
				end
			end
		end
	end
end

function listenIdle (port)
	local routeNum, packetType, message, dist = coroutine.yield()
	if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
	if routeNum == 0 and packetType == "instruction" then return routeNum, packetType, message end
	for cNum, cInfo in pairs(connectionTable) do
		if cInfo.route == routeNum and cInfo.localport == port then return cNum, packetType, string.match(message, ";(.*)"), dist end
	end
	local conn = {}
	conn.route = routeNum
	conn.name = net.nameFromRoute(routeNum)
	conn.localport = port
	conn.foreignport = string.match(message, "^%d+,(%d+);")
	table.insert(connectionTable, conn)
	return #connectionTable, packetType, string.match(message, ";(.*)"), dist
end

function send (conn, messType, message)
	if not connectionTable[conn] then return false end
	local packetType = ""
	if pTypeLookup[messType] then packetType = pTypeLookup[messType] else return false end
	return net.packet_send(packetType, connectionTable[conn].route, connectionTable[conn].foreignport..","..connectionTable[conn].localport..";"..message)
end

local function getPort()
	local validPort = false
	local portChoice = 51
	while not validPort do
		if net.socketTable[portChoice] then
			portChoice = portChoice + 1
		else
			net.socketTable[portChoice] = true
			validPort = true
		end
	end
	return portChoice
end

function broadcast (messType, message, toPort)
	if message == nil then return false end
	if pTypeLookup[messType] then packetType = pTypeLookup[messType] else return false end
	local fromPort = getPort()
	rednet.broadcast(packetType..":"..toPort..","..fromPort..";"..message)
	return fromPort
end

function lessResponse (port, time)
	return listenOnPort(port, time)
end

local function listenOnPort (port, time)
	local listenTimeOut = nil
	local messRecv = false
	if time then listenTimeOut = os.startTimer(time) end
	while not messRecv do
		local event, p1, p2, p3 = os.pullEvent()
		if event == "timer" and p1 == listenTimeOut then
			return false
		elseif event == "rednet_message" then
			routeNum, packetType, message, dist = net.rednet_message(p1, p2, p3)
			if string.match(message, "^(%d+),") == port then
				if pTypeLookup[packetType] then packetType = pTypeLookup[packetType] end
				messRecv = true
			end
		end
	end
	return packetType, message, dist
end

function awaitResponse (conn, time)
	packetType, message, dist = listenOnPort(connection.localport, time)
	if packetType then
		return packetType, string.match(message, ";(.*)"), dist
	end
end

function open (idString, serverPort, timeout)
	local routeNum
	if string.sub(idString, 1, 2) == "i;" then
		--connecting to raw ID.
		routeNum = net.routeFromCID(string.sub(idString, 3))
	elseif string.sub(idString, 1, 2) == "r;" then
		--connecting to route ID.
		routeNum = string.sub(idString, 3)
	else
		--try to look up a hostname.
		routeNum = net.routeFromName(idString)
	end
	if routeNum then
		local portChoice = getPort()
		net.packet_send("SQ", routeNum, serverPort..","..portChoice..";connect")
		pType, mess = listenOnPort(portChoice, timeout)
		if not pType then return false end
		if pType == "response" then
			local conn = {}
			conn.route = routeNum
			conn.name = net.nameFromRoute(routeNum)
			conn.localport = portChoice
			conn.foreignport = serverPort
			table.insert(connectionTable, conn)
			if mess then
				return #connectionTable, mess
			else
				return #connectionTable
			end
		end
	end
	return false
end

function close (conn, message, quiet)
	if connectionTable[conn] then
		if quiet ~= true then
			if message == nil then message = "disconnect" end
			if connectionTable[conn].server ~= nil then message = connectionTable[conn].server..";"..message end
			net.packet_send("SC", connectionTable[conn].route, message)
		end
		net.socketTable[connectionTable[conn].localport] = nil
		connectionTable[conn] = nil
		return true
	end
	return false
end

function isTurtle (conn)
	if connectionTable[conn] then
		if net.routeTable[connectionTable[conn].route].type == "T" then return true else return false end
	else
		return nil
	end
end

function name (conn)
	if connectionTable[conn] then
		return connectionTable[conn].name
	end
	return false
end

function route (conn)
	if connectionTable[conn] then
		return connectionTable[conn].route
	end
	return false
end
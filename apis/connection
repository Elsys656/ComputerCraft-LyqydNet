connectionTable = {}
pTypeLookup = {
	query = "SQ",
	response = "SR",
	data = "SP",
	done = "SB",
	close = "SC",
	fileQuery = "FQ",
	fileSend = "FS",
	fileResponse = "FR",
	fileHeader = "FH",
	fileData = "FD",
	fileEnd = "FE",
	fileCopy = "FC",
	fileDelete = "FM",
	fileMove = "FV",
	fileMakeDirectory = "FK",
	fileList = "FL",
	fileInformation = "FI",
	fileStatus = "FZ",
	textWrite = "TW",
	textCursorPos = "TC",
	textGetCursorPos = "TG",
	textGetSize = "TD",
	textInfo = "TI",
	textClear = "TE",
	textClearLine = "TL",
	textScroll = "TS",
	textBlink = "TB",
	textColor = "TF",
	textBackground = "TK",
	textIsColor = "TA",
	event = "EV",
	instruction = "SI",
	rednet = "RM"
	SQ = "query",
	SR = "response",
	SP = "data",
	SB = "done",
	SC = "close",
	FQ = "fileQuery",
	FS = "fileSend",
	FR = "fileResponse",
	FH = "fileHeader",
	FD = "fileData",
	FE = "fileEnd",
	FC = "fileCopy",
	FM = "fileDelete",
	FV = "fileMove",
	FK = "fileMakeDirectory",
	FL = "fileList",
	FI = "fileInformation",
	FZ = "fileStatus",
	TW = "textWrite",
	TC = "textCursorPos",
	TG = "textGetCursorPos",
	TD = "textGetSize",
	TI = "textInfo",
	TE = "textClear",
	TL = "textClearLine",
	TS = "textScroll",
	TB = "textBlink",
	TF = "textColor",
	TK = "textBackground",
	TA = "textIsColor",
	EV = "event",
	SI = "instruction",
	RM = "rednet"
}

local function getPort()
	local validPort = false
	local portChoice = 51
	while not validPort do
		if net.socketTable[portChoice] then
			portChoice = portChoice + 1
		else
			net.socketTable[portChoice] = true
			validPort = true
		end
	end
	return portChoice
end

local Connection = {
	newPacket = function(self, pType, message)
		return packet.new(pType, self.remote, message, self.remoteport, self.localport)
	end,
	open = function(self, timeout)
		if self.state ~= "open" then
			self.localport = getPort()
			net.send(self:newPacket("SQ", "connect"))
			local response = self:listen(timeout)
			if response.pType == "SR" then
				self.state = "open"
				return response.payload
			else
				return false
			end
		end
	end,
	send = function(self, pType, message)
		if self.state == "open" then
			local packetType = pType
			if pType:len() > 2 then
				if packet.types[pType] then packetType = packet.types[pType] else return false end
			end
			local pack = self:newPacket(packetType, message)
			return net.send(pack)
		else return false end
	end,
	listen = function(self, timeout)
		if self.state == "open" then
			local timer
			if timeout then timer = os.startTimer(timeout) end
			while true do
				local event = {os.pullEvent()}
				if event[1] == "socket_message" then
					--be really sure the packet is intended for us.
					if event[2].toSock == self.localport and event[2].fromSock == self.remoteport and event[2].origin == self.remote and event[2].destination == os.computerID() then
						return event[2]
					end
				elseif event[1] == "timer" and timeout and event[2] == timer then
					return false
				end
			end
		else return false end
	end,
	close = function(self, message, quiet)
		if self.state == "open" then
			if quiet ~= true then
				local pack = self:newPacket("SC", message or "disconnect")
				net.send(pack)
			end
			self.state = "closed"
			return true
		else return false end
		--must explicitly compare to true so that a string value will not evaluate as also true.
		--look into freeing socket.
		--if net.socketTable[connectionTable[conn].localport] == true then net.socketTable[connectionTable[conn].localport] = nil end
	end,
	isTurtle = function(self)
		if net.routeTable[self:route()].type == "T" then return true else return false end
	end,
	name = function(self)
		return net.nameFromRoute(self:route())
	end,
	route = function(self)
		return net.routeFromCID(self.remote)
	end,
	destroy = function(self)
		for cNum, cInfo in pairs(connection.connectionTable) do
			if cInfo == self then
				table.remove(connection.connectionTable, cNum)
			end
		end
	end,
}

local cmetatable = {__index = Connection}

function new(destination, port, localport)
	local instance = {
		--get a local port when opening the connection unless specified.
		localport = localport,
		remoteport = port,
		remote = destination,
		state = "new",
	}
	--if a local port is specified, assume that the connection is already open.
	if localport then instance.state = "open" end
	setmetatable(instance, cmetatable)
	table.insert(connection.connectionTable, instance)
	return instance
end

--searches for a connection matching inbound packet details.
function find(pack)
	for cNum, cInfo in pairs(connection.connectionTable) do
		if cInfo.remote == pack.origin and cInfo.remoteport == pack.fromSock and cInfo.localport == pack.toSock then
			return cNum, cInfo
		end
	end
	return false
end

function listen(port, timeout)
	local timer
	if timeout then timer = os.startTimer(timeout) end
	while true do
		local event = {os.pullEvent()}
		if event[1] == "socket_message" then
			if event[2].toSock == port and event[2].destination == os.computerID() then
				local found, conn = connection.find(event[2])
				if found then
					return event[2], conn
				else
					return event[2], connection.new(event[2].origin, event[2].fromSock, event[2].toSock)
				end
			end
		elseif event[1] == "timer" and timeout and event[2] == timer then
			return false
		end
	end
end


function text (conn)
	local textTable = {}
	textTable.conn = conn
	textTable.write = function(text)
		return textTable.conn:send("textWrite", text)
	end
	textTable.clear = function()
		return textTable.conn:send("textClear", "nil")
	end
	textTable.clearLine = function()
		return textTable.conn:send("textClearLine", "nil")
	end
	textTable.getCursorPos = function()
		if textTable.conn:send("textGetCursorPos", "nil") then
			local response = textTable.conn:listen(2)
			if response and packet.types[response.type] == "textInfo" then
				local x, y = string.match(response.payload, "(%d+),(%d+)")
				return tonumber(x), tonumber(y)
			end
		else return false end
	end
	textTable.setCursorPos = function(x, y)
		return textTable.conn:send("textCursorPos", math.floor(x)..","..math.floor(y))
	end
	textTable.setCursorBlink = function(b)
		if b then
			return textTable.conn:send("textBlink", "true")
		else
			return textTable.conn:send("textBlink", "false")
		end
	end
	textTable.getSize = function()
		if textTable.conn:send("textGetSize", "nil") then
			local response = textTable.conn:listen(2)
			if response and packet.types[response.type] == "textInfo" then
				local x, y = string.match(response.payload, "(%d+),(%d+)")
				return tonumber(x), tonumber(y)
			end
		else return false end
	end
	textTable.scroll = function(lines)
		return textTable.conn:send("textScroll", lines)
	end
	textTable.isColor = function()
		if textTable.conn:send("textIsColor", "nil") then
			local response = textTable.conn:listen(2)
			if response and packet.types[response.type] == "textInfo" then
				if response.payload == "true" then
					return true
				end
			end
		end
		return false
	end
	textTable.isColour = textTable.isColor
	textTable.setTextColor = function(color)
		return textTable.conn:send("textColor", tostring(color))
	end
	textTable.setTextColour = textTable.setTextColor
	textTable.setBackgroundColor = function(color)
		return textTable.conn:send("textBackground", tostring(color))
	end
	textTable.setBackgroundColour = textTable.setBackgroundColor
	return textTable
end

function processText(conn, pType, value)
	if not pType then return false end
	if pType == "textWrite" and value then
		term.write(value)
	elseif pType == "textClear" then
		term.clear()
	elseif pType == "textClearLine" then
		term.clearLine()
	elseif pType == "textGetCursorPos" then
		local x, y = term.getCursorPos()
		conn:send("textInfo", math.floor(x)..","..math.floor(y))
	elseif pType == "textCursorPos" then
		local x, y = string.match(value, "(%d+),(%d+)")
		term.setCursorPos(tonumber(x), tonumber(y))
	elseif pType == "textBlink" then
		if value == "true" then
			term.setCursorBlink(true)
		else
			term.setCursorBlink(false)
		end
	elseif pType == "textGetSize" then
		x, y = term.getSize()
		conn:send("textInfo", x..","..y)
	elseif pType == "textScroll" and value then
		term.scroll(tonumber(value))
	elseif pType == "textIsColor" then
		conn:send("textInfo", tostring(term.isColor()))
	elseif pType == "textColor" and value then
		value = tonumber(value)
		if (value == 1 or value == 32768) or term.isColor() then
			term.setTextColor(value)
		end
	elseif pType == "textBackground" and value then
		value = tonumber(value)
		if (value == 1 or value == 32768) or term.isColor() then
			term.setBackgroundColor(value)
		end
	end
	return
end